use b_error::BError;
use crate::lexer;
use crate::ast;

grammar;

pub Module = <Declaration*>;

Declaration: ast::Declaration = {
    "fn" <Function>,
};

Function: ast::Declaration = {
    <a:Ident> <b:ArgList> <c:RetDecl> <d:Body> => {
        ast::Declaration::Function(
            ast::Function {
                name: a,
                args: b,
                ret: c,
                body: d,
            }
        )
    },
};

Ident: ast::Ident = {
    "<ident>" => ast::Ident(<>.ident_string()),
};

ArgList: ast::ArgList = {
    "<paren-tree>" => ast::ArgList(ast::ParenTree(<>.tree())),
};

RetDecl: ast::RetDecl = {
    "->" <Type> => ast::RetDecl(<>),
};

Body: ast::Body = {
    "<brace-tree>" => ast::Body(ast::BraceTree(<>.tree())),
}

Type: ast::Type = {
    "I32" => ast::Type::I32,
};

extern {
    type Location = usize;
    type Error = BError;

    enum lexer::Token {
        "fn" => lexer::Token::IdentFn,
        "I32" => lexer::Token::IdentI32,
        "<ident>" => (
            lexer::Token::Ident(_)
        ),
        "->" => (
            lexer::Token::Punctuation(
                lexer::Punctuation::RightArrow
            )
        ),       
        "<paren-tree>" => lexer::Token::ParenTree(_),
        "<brace-tree>" => lexer::Token::BraceTree(_),
    }
}
